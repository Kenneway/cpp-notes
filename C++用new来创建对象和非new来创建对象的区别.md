# C++用new来创建对象和非new来创建对象的区别

我们都知道C++中有三种创建对象的方法，如下：

	#include <iostream>
	using namespace std;

	class A
	{
	private:
		int n;
	public:
		A(int m):n(m)
		{
		}
		~A(){}
	};

	int main()
	{
		A a(1);  //栈中分配
		A b = A(1);  //栈中分配
		A* c = new A(1);  //堆中分配
	　　delete c;
		return 0;
	}

第一种和第二种没什么区别，一个隐式调用，一个显式调用，两者都是在进程虚拟地址空间中的栈中分配内存，而第三种使用了new，在堆中分配了内存，而栈中内存的分配和释放是由系统管理，而堆中内存的分配和释放必须由程序员手动释放，所以这就产生一个问题是把对象放在栈中还是放在堆中的问题，这个问题又和堆和栈本身的区别有关：

这里面有几个问题：

	1. 堆和栈最大可分配的内存的大小
	2. 堆和栈的内存管理方式
	3. 堆和栈的分配效率

首先针对第一个问题，一般来说对于一个进程栈的大小远远小于堆的大小，在linux中，你可以使用ulimit -s (单位kb)来查看一个进程栈的最大可分配大小，一般来说不超过8M，有的甚至不超过2M，不过这个可以设置，而对于堆你会发现，针对一个进程堆的最大可分配的大小在G的数量级上，不同系统可能不一样，比如32位系统最大不超过2G，而64为系统最大不超过4G，所以当你需要一个分配的大小的内存时，请用new，即用堆。

其次针对第二个问题，栈是系统数据结构，对于进程/线程是唯一的，它的分配与释放由操作系统来维护，不需要开发者来管理。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时，这些存储单元会被自动释放。栈内存分配运算内置于处理器的指令集中，效率很高，不同的操作系统对栈都有一定的限制。 堆上的内存分配，亦称动态内存分配。程序在运行的期间用malloc申请的内存，这部分内存由程序员自己负责管理，其生存期由开发者决定：在何时分配，分配多少，并在何时用free来释放该内存。这是唯一可以由开发者参与管理的内存。使用的好坏直接决定系统的性能和稳定。

由上可知，但我们需要的内存很少，你又能确定你到底需要多少内存时，请用栈。而当你需要在运行时才知道你到底需要多少内存时，请用堆。

最后针对第三个问题，栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率 比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在 堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会 分 到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。

由上可知，能用栈则用栈。

	#include <stdio.h>
	#include <stdlib.h>  
	void main()
	{
		int n,*p,i,j,m;
		printf("本程序可对任意个整数排序;\n");
		printf("请输入整数的总个数: ");
		scanf("%d",&n);
		p=(int *)calloc(n,sizeof(int));    //运行时决定内存分配大小
		if(p==0)   {
		printf("分配失败!\n");  
		exit(1);  
	}


